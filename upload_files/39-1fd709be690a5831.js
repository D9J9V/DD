"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[39],{51852:function(t,e,r){var o=r(70865),i=r(96670),n=r(26297),a=r(52322),s=r(30660);r(97638);e.Z=function(t){var e=t.children,r=t.placement,c=void 0===r?"top":r,l=t.overlay,d=t.id,h=t.destroyTooltipOnHide,u=t.overlayClassName,w=void 0===u?"":u,p=(0,n.Z)(t,["children","placement","overlay","id","destroyTooltipOnHide","overlayClassName"]);return(0,a.jsx)(s.Z,(0,i.Z)((0,o.Z)({placement:c,overlay:(0,a.jsx)("div",{className:"bg-white p2 text-sm flex",children:l}),overlayInnerStyle:{borderWidth:0},destroyTooltipOnHide:h,overlayClassName:w,id:d},p),{children:e}))}},34699:function(t,e,r){r.d(e,{j3:function(){return x}});var o=r(36609),i=r(98020),n=r(12617),a=r(6110),s=(r(75361),r(63827)),c=r(95629),l=r(20606),d=r(83478),h=r(16492);const u=globalThis.fetch,w=(globalThis.FormData,globalThis.Headers,globalThis.Request,globalThis.Response,globalThis.Blob),p=(globalThis.File,globalThis.ReadableStream,h.X),f=new URL("https://nftstorage.link/"),y=(t,e={})=>{const r=e.gateway||f;return"ipfs:"===(t=new URL(String(t))).protocol?new URL(`/ipfs/${t.href.slice("ipfs://".length)}`,r):t};class m{constructor(t,e,r){this._version=t,this._roots=e,this._blockstore=r}get version(){return this._version}get blockstore(){return this._blockstore}async getRoots(){return this._roots}has(t){return this._blockstore.has(t)}async get(t){return{cid:t,bytes:await this._blockstore.get(t)}}blocks(){return this._blockstore.blocks()}async*cids(){for await(const t of this.blocks())yield t.cid}}class g{constructor(t,e,r){this.ipnft=t,this.url=e,this.data=r,Object.defineProperties(this,{ipnft:{enumerable:!0,writable:!1},url:{enumerable:!0,writable:!1},data:{enumerable:!1,writable:!1}})}embed(){return g.embed(this)}static embed({data:t}){return b(t,{gateway:f})}static async encode(t){const e=new p,[r,o]=S(t),i=JSON.parse(JSON.stringify(o)),n=JSON.parse(JSON.stringify(o));for(const[c,l]of r.entries()){const t=l.name||"blob",r=l.stream(),{root:o}=await(0,a.P)({input:[{path:t,content:r}],blockstore:e,wrapWithDirectory:!0}),s=new URL(`ipfs://${o}/${t}`),d=c.split(".");j(i,d,s),j(n,d,o)}const{root:s}=await(0,a.P)({input:[{path:"metadata.json",content:JSON.stringify(i)}],blockstore:e,wrapWithDirectory:!1}),h=await c.cv({value:{...n,"metadata.json":s,type:"nft"},codec:d,hasher:l.sha256});return await e.put(h.cid,h.bytes),{cid:h.cid,token:new g(h.cid.toString(),`ipfs://${h.cid}/metadata.json`,i),car:new m(1,[h.cid],e)}}}const b=(t,e)=>C(t,k,v,e),k=t=>t instanceof URL,v=(t,e)=>[t,y(e,t)],E=(t,e,r)=>(t.set(r.join("."),e),[t,void 0]),T=t=>t instanceof w,S=t=>D(t,T,E,new Map,[]),C=(t,e,r,o)=>{const[,i]=D(t,e,r,o,[]);return i},D=(t,e,r,o,i)=>{return e(t,o,i)?r(o,t,i):Array.isArray(t)?R(t,e,r,o,i):"object"===typeof(n=t)&&null!=n?L(t,e,r,o,i):[o,t];var n},L=(t,e,r,o,i)=>{let n=o;const a={};for(const[s,c]of Object.entries(t)){const[t,o]=D(c,e,r,n,[...i,s]);a[s]=o,n=t}return[n,a]},R=(t,e,r,o,i)=>{const n=[];let a=o;for(const[s,c]of t.entries()){const[t,o]=D(c,e,r,a,[...i,s]);n[s]=o,a=t}return[a,n]},j=(t,e,r)=>{const o=e.length-1;let i=t;for(let[n,a]of e.entries())n===o?i[a]=r:i=i[a]};var N=r(56946);function _(){const t=s(30,1e4);return()=>t((()=>{}))}const O=_();class x{constructor({token:t,did:e,endpoint:r=new URL("https://api.nft.storage"),rateLimiter:o}){this.token=t,this.endpoint=r,this.rateLimiter=o||_(),this.did=e}static auth({token:t,did:e}){if(!t)throw new Error("missing token");return{Authorization:`Bearer ${t}`,"X-Client":"nft.storage/js",...e?{"x-agent-did":e}:{}}}static async storeBlob(t,e,r){const o=new p;let i;try{const{cid:n,car:a}=await x.encodeBlob(e,{blockstore:o});await x.storeCar(t,a,r),i=n.toString()}finally{await o.close()}return i}static async storeCar({endpoint:t,rateLimiter:e=O,...r},a,{onStoredChunk:s,maxRetries:c,decoders:l,signal:d}={}){const h=new URL("upload/",t),p=x.auth(r),f=10485760,y=a instanceof w?await n.o.fromBlob(a,f,{decoders:l}):new n.o(a,f,{decoders:l}),m=(0,o.vs)(3,(async function(t){const r=[];for await(const e of t)r.push(e);const o=new w(r,{type:"application/car"}),n=await i((async()=>{let t;await e();try{t=await u(h.toString(),{method:"POST",headers:p,body:o,signal:d})}catch(n){throw d&&d.aborted?new i.AbortError(n):n}if(429===t.status)throw new Error("rate limited");const r=await t.json();if(!r.ok){if(401===t.status)throw new i.AbortError(r.error.message);throw new Error(r.error.message)}return r.value.cid}),{retries:null==c?5:c});return s&&s(o.size),n}));let g;for await(const o of m(y.cars()))g=o;return g}static async storeDirectory(t,e,r){const o=new p;let i;try{const{cid:n,car:a}=await x.encodeDirectory(e,{blockstore:o});await x.storeCar(t,a,r),i=n.toString()}finally{await o.close()}return i}static async store(t,e,r){const{token:o,car:i}=await x.encodeNFT(e);return await x.storeCar(t,i,r),o}static async status({endpoint:t,rateLimiter:e=O,...r},o,i){const n=new URL(`${o}/`,t);await e();const a=await u(n.toString(),{method:"GET",headers:x.auth(r),signal:i&&i.signal});if(429===a.status)throw new Error("rate limited");const s=await a.json();if(s.ok)return{cid:s.value.cid,deals:B(s.value.deals),size:s.value.size,pin:z(s.value.pin),created:new Date(s.value.created)};throw new Error(s.error.message)}static async check({endpoint:t,rateLimiter:e=O},r,o){const i=new URL(`check/${r}/`,t);await e();const n=await u(i.toString(),{signal:o&&o.signal});if(429===n.status)throw new Error("rate limited");const a=await n.json();if(a.ok)return{cid:a.value.cid,deals:B(a.value.deals),pin:a.value.pin};throw new Error(a.error.message)}static async delete({endpoint:t,rateLimiter:e=O,...r},o,i){const n=new URL(`${o}/`,t);await e();const a=await u(n.toString(),{method:"DELETE",headers:x.auth(r),signal:i&&i.signal});if(429===a.status)throw new Error("rate limited");const s=await a.json();if(!s.ok)throw new Error(s.error.message)}static async encodeNFT(t){return U(t),g.encode(t)}static async encodeBlob(t,{blockstore:e}={}){if(0===t.size)throw new Error("Content size is 0, make sure to provide some content");return A([W("blob",t)],{blockstore:e,wrapWithDirectory:!1})}static async encodeDirectory(t,{blockstore:e}={}){let r=0;const o=N(t,(async function*(t){for await(const e of t)yield W(e.name,e),r+=e.size})),i=await A(o,{blockstore:e,wrapWithDirectory:!0});if(0===r)throw new Error("Total size of files should exceed 0, make sure to provide some content");return i}storeBlob(t,e){return x.storeBlob(this,t,e)}storeCar(t,e){return x.storeCar(this,t,e)}storeDirectory(t,e){return x.storeDirectory(this,t,e)}status(t,e){return x.status(this,t,e)}delete(t,e){return x.delete(this,t,e)}check(t,e){return x.check(this,t,e)}store(t,e){return x.store(this,t,e)}}const U=({name:t,description:e,image:r,decimals:o})=>{if("string"!==typeof t)throw new TypeError("string property `name` identifying the asset is required");if("string"!==typeof e)throw new TypeError("string property `description` describing asset is required");if(!(r instanceof w))throw new TypeError("property `image` must be a Blob or File object");if(r.type.startsWith("image/")||console.warn("According to ERC721 Metadata JSON Schema 'image' must have 'image/*' mime type.\n\nFor better interoperability we would highly recommend storing content with different mime type under 'properties' namespace e.g. `properties: { video: file }` and using 'image' field for storing a preview image for it instead.\n\nFor more context please see ERC-721 specification https://eips.ethereum.org/EIPS/eip-721"),"undefined"!==typeof o&&"number"!==typeof o)throw new TypeError("property `decimals` must be an integer value")},A=async(t,{blockstore:e,wrapWithDirectory:r}={})=>{e=e||new p;const{root:o}=await(0,a.P)({input:t,blockstore:e,wrapWithDirectory:r});return{cid:o,car:new m(1,[o],e)}},B=t=>t.map((t=>{const{dealActivation:e,dealExpiration:r,lastChanged:o}={dealExpiration:null,dealActivation:null,...t};return{...t,lastChanged:new Date(o),...e&&{dealActivation:new Date(e)},...r&&{dealExpiration:new Date(r)}}})),z=t=>({...t,created:new Date(t.created)});function W(t,e){let r;return{path:t,get content(){return r=r||e.stream(),r}}}}}]);